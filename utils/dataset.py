import cv2
import json
import numpy as np


def load_city(file_names):
    """
    Simply load the CITY dataset from a list of image names
    """
    # the image is synthesized using a reversed channel order
    images = [cv2.imread(file_name)[..., ::-1] for file_name in file_names]
    intrinsic = np.array([
        [3.125 * 256, 0, 256],
        [0, 3.125 * 256, 256],
        [0, 0, 1]]
    )
    return images, intrinsic


def load_house(file_names):
    """
    Simply load the CITY dataset from a list of image names
    """
    images = [cv2.imread(file_name) for file_name in file_names]
    intrinsic = np.array([
        [2362.12, 0, 384],
        [0, 2366.12, 288],
        [0, 0, 1]]
    )
    return images, intrinsic


def load_city_raw_wireframes(file_names):

    """
    Load Ground-Truth Correspondence Point for the City Dataset.
    This is a synthetic dataset generated by the Blender software.

    Args:
        file_names (list): list of image names

    Returns:
        juncs (list): list of junctions, each element is an ndarray with shape (num_points, 2)
            corresponding to all the junctions of an image
        lines (list): list of lines, each element is also a list specifying the connectivity of junctions
            each element is (start_junc_id, end_junc_id) which means the index in the junction array
        junc_ids (list): list of junction ids; each element is ndarray with shape (num_points,)
            if two junction has the same id, it means they are the same point in the original 3D space
    """
    # hard code image size since the dataset is fixed
    image_size = 512

    juncs, lines, junc_ids = [], [], []
    for file_name in file_names:
        label_name = file_name.replace('.jpg', '_label.json')
        js = json.load(open(label_name))
        line = np.array(js['line'])
        juncidx = js["junindex"]
        junc = np.array(js["junction"])

        junc = _opengl2cv(junc, image_size // 2)

        lines.append(line)
        juncs.append(junc)
        junc_ids.append(juncidx)

    return juncs, lines, junc_ids


def load_city_pts(file_names):
    """
    Load Ground-Truth Correspondence Point for the City Dataset.
    This is a synthetic dataset generated by the Blender software.

    Args:
        file_names (list): list of image names

    Returns:
        pts (np.ndarray): an array of corresponding points
            shape: (num_image, num_matched_points, 2)
            The order of the last dimension is (x, y)
    """
    # hard code image size since the dataset is fixed
    image_size = 512

    juncs, lines, junc_ids = [], [], []
    for file_name in file_names:
        label_name = file_name.replace('.jpg', '_label.json')
        js = json.load(open(label_name))
        line = np.array(js['line'])
        juncidx = js["junindex"]
        junc = np.array(js["junction"])

        junc = _opengl2cv(junc, image_size // 2)

        lines.append(line)
        juncs.append(junc)
        junc_ids.append(juncidx)

    # in the above, we load the junctions from each image separately
    # however, to get correspondence, we need the same junction across images
    pts = extract_matched_points(juncs, junc_ids)
    return pts


def load_noisy_city_pts(file_names, noisy_level=1.0):
    """
    Load Ground-Truth Correspondence Point for the City Dataset.
    This is a synthetic dataset generated by the Blender software.

    Args:
        file_names (list): list of image names
        noisy_level (float): specify how much noise we add to the junction points

    Returns:
        pts (np.ndarray): an array of corresponding points
            shape: (num_image, num_matched_points, 2)
            The order of the last dimension is (x, y)
    """
    # hard code image size since the dataset is fixed
    image_size = 512

    pts = []
    for file_name in file_names:
        label_name = file_name.replace('.jpg', '_label.json')
        js = json.load(open(label_name))
        juncidx = np.array(js["junindex"])
        junc = np.array(js["junction"])
        junc = _opengl2cv(junc, image_size // 2)
        # perturb with Gaussian noisy
        junc += np.random.normal(scale=noisy_level, size=(junc.shape[0], 2))
        pts.append(junc[juncidx != -1])

    return pts


def _opengl2cv(x, image_size):
    assert x.shape[1] == 2
    x = x.copy()
    x[:, 1] *= -1
    x *= image_size
    x += image_size
    return x


def extract_matched_points(juncs, junc_ids):
    """
    Args:
        juncs (list): list of numpy array, shape of each array (num_points, 2)
        junc_ids (list): list of list, shape of each array (num_points,)

    Return:
        matched_pts (np.ndarray): an array of corresponding points
            shape: (num_image, num_matched_points, 2)
    """
    num_image = len(juncs)
    # get all junc_ids
    all_junc_ids = np.hstack(junc_ids)
    unique, counts = np.unique(all_junc_ids, return_counts=True)
    matched_ids = unique[np.where(counts == num_image)]

    num_matched_pts = len(matched_ids)
    matched_pts = -np.ones((num_image, num_matched_pts, 2))

    for idx, (j, ji) in enumerate(zip(juncs, junc_ids)):
        matched_pts[idx] = np.array([j[np.where(ji == matched_id)].squeeze() for matched_id in matched_ids])

    return matched_pts
